/**
 * Declares instance variables. <code>init</code> must be called to initialize them.
 * @constructor
 *
 * @param	textarea	the textarea to replace with Loki
 *
 * @class A WYSIWYG HTML editor.
 */
UI.Loki = function(textarea, settings)
{
	var _owner_document; // that of _textarea etc.
	var _window;     //
	var _document;   // _window, _document, and _body are those of _iframe's content
	var _body;       //

	var _root;       //  + root (div)
	var _toolbar;    //  |--- toolbar (div)
	var _textarea_toolbar;     // (same)
	var _textarea;   //  |---get_nearest_bl_ancestor_element textarea
	var _statusbar;  //  |--- statusbar (div)
	var _iframe;     //  |--- iframe
	var _hidden;     //  |--- hidden (input)

	var _settings;
	var _use_p_hack;
	var _state_change_listeners = Array();

	var self = this;


	/**
	 * Returns the HTML of the document currently being edited.
	 *
	 * @return	string	the HTML of the document currently being edited.
	 */
	this.get_html = function()
	{
		// For some reason, this doesn't work (clean still cleans
		// _body, not clone) ... but it's not really necessary, either
// 		var clone = _body.cloneNode(true);
// 		Util.Clean.clean(clone);
// 		return clone.innerHTML;

		Util.Clean.clean(_body);
		return _body.innerHTML;
	};

	this.get_dirty_html = function()
	{
		return _body.innerHTML;
	};

	/**
	 * Sets the HTML of the document.
	 *
	 * @param	html	the HTML of the document
	 */
	this.set_html = function(html)
	{
		_body.innerHTML = html;
	};

	/**
	 * Copies the value of the iframe to the value of the textarea.
	 */
	this.copy_iframe_to_hidden = function()
	{
		_hidden.value = self.get_html();
	};

	/**
	 * Toggles textarea and iframe.
	 */
	this.toggle_iframe_textarea = function()
	{
		if ( _textarea.parentNode == _root )
		{
			self.textarea_to_iframe();
		}
		else
		{
			self.iframe_to_textarea();
		}
	};
	
	/**
	 * Shows textarea instead of iframe.
	 */
	this.iframe_to_textarea = function()
	{
		_textarea.value = self.get_html();
		_root.replaceChild(_textarea, _iframe);
		_root.removeChild(_hidden);
		_root.replaceChild(_textarea_toolbar, _toolbar);
		_textarea.focus();	
	};

	/**
	 * Shows iframe instead of textarea.
	 */
	this.textarea_to_iframe = function()
	{
		self.set_html(_textarea.value);
		_root.replaceChild(_iframe, _textarea);
		_root.appendChild(_hidden);
		_init_async();
		_root.replaceChild(_toolbar, _textarea_toolbar);
		_window.focus();	
	};


	/**
	 * Initializes instance variables.
	 *
	 * @param	textarea	the textarea to replace with Loki
	 */
	this.init = function(textarea, settings)
	{
		_settings = settings;

		_textarea = textarea;
		_owner_document = _textarea.ownerDocument;

		_use_p_hacks = _use_p_hacks();

		// Create the various elements
		_create_root();
		_create_toolbar();
		_create_textarea_toolbar();
		_create_iframe();
		_create_statusbar();
		_create_hidden();

		// And append them to root
		_root.appendChild( _toolbar );
		_root.appendChild( _iframe );
		_root.appendChild( _statusbar );
		_root.appendChild( _hidden );

		// Replace the textarea with root
		_replace_textarea();

		// Append style sheets
		_append_owner_document_style_sheets();

		// Continue the initialization, but asynchronously
		_init_async();
	};

	/**
	 * Finishes initializing instance variables, but does so
	 * asynchronously. All initing that requires _window or _document
	 * to be available should be done in this function, because this
	 * function waits until _window and _document are available to do
	 * anything.
	 */
	var _init_async = function()
	{
		try
		{
			// Try to init references to iframe content's window and
			// document ...
			try
			{
				_window = _iframe.contentWindow;
				_document = _window.document;
				if ( _window == null || _document == null )
					throw(new Error('UI.Loki._init_iframe: Couldn\'t init iframe. Will try again.'));
			}
			// ... but if the window or document aren't available yet
			// (because the 'about:blank' document hasn't finished
			// loading), try again in a few milliseconds.
			//
			// Be sure that if you change the name of the present
			// function, you also change what you call in setTimeout
			// below.
			catch(f)
			{
				setTimeout(_init_async, 10);
				return;
			}

			// Do things that require _window or _document

			// Write out a blank document
			_clear_document();

			// Append style sheets for the iframe
			_append_document_style_sheets();

			// Init reference to that document's body
			_body = _document.getElementsByTagName('BODY').item(0);
			Util.Element.add_class(_body, 'contentMain'); // so front-end stylesheets work

			// Set body's html to textarea's value
			self.set_html( _textarea.value );

			// Make the document editable
			_make_document_editable();

			// Add certain event listeners to the document and elsewhere
			_add_document_listeners();
			_add_state_change_listeners();
		}
		catch(e)
		{
			// If anything goes wrong during initialization, first
			// revert to the textarea before re-throwing the error
			self.iframe_to_textarea();
			throw(new Error('UI.Loki._init_async: I reverted to source view because the following ' +
							'error prevented Loki from initializing: <<' + e.message + '>>.'));
		}
	};

	/**
	 *
	 */
	var _use_p_hacks = function()
	{
		return navigator.product == 'Gecko';
	};

	/**
	 * Creates the root element for Loki.
	 */
	var _create_root = function()
	{
		_root = _owner_document.createElement('DIV');
		Util.Element.add_class(_root, 'loki');
	};

	/**
	 * Creates the toolbar, populated with the appropriate buttons.
	 */
	var _create_toolbar = function()
	{
		// Create the toolbar itself
		_toolbar = _owner_document.createElement('DIV');
		Util.Element.add_class(_toolbar, 'toolbar');

		// Create a function to add a button to the toolbar
		var add_button = function(image, title, click_listener, state_querier)
		{
			var button = _owner_document.createElement('IMG');
			button.src = _settings.base_uri + 'images/nav/' + image;
			button.setAttribute('title', title);

			Util.Event.add_event_listener(button, 'mouseover', function() { Util.Element.add_class(button, 'hover'); });
			Util.Event.add_event_listener(button, 'mouseout', function() { Util.Element.remove_class(button, 'hover'); });
			Util.Event.add_event_listener(button, 'mousedown', function() { Util.Element.add_class(button, 'active'); });
			Util.Event.add_event_listener(button, 'mouseup', function() { Util.Element.remove_class(button, 'active'); });
			Util.Event.add_event_listener(button, 'click', click_listener);

			// make the button appear depressed whenever the current selection is in a relevant (bold, heading, etc) region
			if ( state_querier != null )
			{
				_state_change_listeners.push( 
					function()
					{
						if ( state_querier() &&	(Util.Element.get_all_classes(button)).indexOf('active') == -1 ) 
							Util.Element.add_class(button, 'active' /*'selected'*/);
						else
							if ( !state_querier() && (Util.Element.get_all_classes(button)).indexOf('active') > -1 )
								Util.Element.remove_class(button, 'active' /*'selected'*/);
					}
				);
			}

			Util.Element.add_class(button, 'tb');
			button.width = 21;
			button.height = 20;
			button.border = 0;
			button.setAttribute('unselectable', 'on');

			_toolbar.appendChild(button);
		};

		// Add each button to the toolbar
// 		if ( _options.settings & UI.Loki_Options.strong ) 
// 		if ( _options.settings & UI.Loki_Options.emphasis ) 
// 		if ( UI.Loki_Options.test('underline', _options.settings) )

		if ( _settings.options.test('strong') ) add_button('bold.gif', 'Bold', function() { _exec_command('Bold'); }, function() { return _query_command_state('Bold'); });
		if ( _settings.options.test('em') ) add_button('italic.gif', 'Italic', function() { _exec_command('Italic'); }, function() { return _query_command_state('Italic'); });
		if ( _settings.options.test('underline') ) add_button('underline.gif', 'Underline', function() { _exec_command('Underline'); }, function() { return _query_command_state('Underline'); });
		if ( _settings.options.test('headline') ) add_button('header.gif', 'Headline', function() { _toggle_block('h3'); }, function() { return _query_command_state('FormatBlock') == 'h3'; });
		if ( _settings.options.test('pre') ) add_button('pre.gif', 'Preformatted', function() { _toggle_block('pre'); }, function() { return _query_command_state('FormatBlock') == 'pre'; });
		if ( _settings.options.test('linebreak') ) add_button('break.gif', 'Carriage return', function() { _insert_br(); });
		if ( _settings.options.test('hrule') ) add_button('hr.gif', 'Horizontal rule', function() { _insert_hr(); });
		if ( _settings.options.test('highlight') ) add_button('highlight.gif', 'Color background', function() { _highlight_paragraph(); }, function() { return _query_highlight_paragraph(); } );
		if ( _settings.options.test('alignleft') ) add_button('leftalign.gif', 'Left align', function() { _exec_command('JustifyLeft'); }, function() { return _query_command_state('JustifyLeft'); });
		if ( _settings.options.test('aligncenter') ) add_button('center.gif', 'Center align', function() { _exec_command('JustifyCenter'); }, function() { return _query_command_state('JustifyCenter'); });
		if ( _settings.options.test('alignright') ) add_button('rightalign.gif', 'Right align', function() { _exec_command('JustifyRight'); }, function() { return _query_command_state('JustifyRight'); });
		if ( _settings.options.test('olist') ) add_button('ol.gif', 'Ordered list' , function() { _toggle_list('ol'); });
		if ( _settings.options.test('ulist') ) add_button('ul.gif', 'Unordered list', function() { _toggle_list('ul'); });
		if ( _settings.options.test('indenttext') ) add_button('indent.gif', 'Indent text', function() { _exec_command('Indent'); });
		if ( _settings.options.test('indenttext') ) add_button('outdent.gif', 'Remove indent', function() { _exec_command('Outdent'); });
		//if ( _settings.options.test('findtext') ) add_button('findText.gif', 'Find and replace text', function() { _open_dialog('find_replace_text'); });
		//if ( _settings.options.test('table') ) add_button('insertTable.gif', 'Iinsert table, function() { _open_dialog('table'); });
		if ( _settings.options.test('image') ) add_button('image.gif', 'Insert image', function() { _open_image_dialog(); });
		if ( _settings.options.test('link') ) add_button('link.gif', 'Insert link', function() { _hel_open_link_dialog('link'); });
		//if ( _settings.options.test('anchor') ) add_button('anchorInNav.gif', 'Insert named anchor', function() { _open_dialog('named_anchor'); });
		if ( _settings.options.test('email') ) add_button('email.gif', 'Insert link to email address', function() { _hel_open_link_dialog('email'); });
		if ( _settings.options.test('assets') ) add_button('insertAssets.gif', 'Insert link to asset', function() { _hel_open_link_dialog('asset'); });
		//if ( _settings.options.test('spell') ) add_button('spellCheck.gif', 'Check spelling', function() { _open_dialog('spell'); });
		//if ( _settings.options.test('merge') ) add_button('spellCheck.gif', 'Insert mail merge form field', function() { _open_dialog('merge'); });
		//if ( _settings.options.test('source') ) add_button('source.gif', 'Toggle source', function() { _alert_clean_html(); });
		if ( _settings.options.test('source') ) add_button('source.gif', 'Toggle source', function() { self.toggle_iframe_textarea(); });
	};

	/**
	 * Creates the toolbar, populated with the appropriate buttons.
	 */
	var _create_textarea_toolbar = function()
	{
		// Create the toolbar itself
		_textarea_toolbar = _owner_document.createElement('DIV');
		Util.Element.add_class(_textarea_toolbar, 'toolbar');

		// Create a function to add a button to the toolbar
		var add_button = function(image, title, click_listener, state_querier)
		{
			var button = _owner_document.createElement('IMG');
			button.src = _settings.base_uri + 'images/nav/' + image;
			button.setAttribute('title', title);

			Util.Event.add_event_listener(button, 'mouseover', function() { Util.Element.add_class(button, 'hover'); });
			Util.Event.add_event_listener(button, 'mouseout', function() { Util.Element.remove_class(button, 'hover'); });
			Util.Event.add_event_listener(button, 'mousedown', function() { Util.Element.add_class(button, 'active'); });
			Util.Event.add_event_listener(button, 'mouseup', function() { Util.Element.remove_class(button, 'active'); });
			Util.Event.add_event_listener(button, 'click', click_listener);

			// make the button appear depressed whenever the current selection is in a relevant (bold, heading, etc) region
			if ( state_querier != null )
			{
				_state_change_listeners.push( 
					function()
					{
						if ( state_querier() &&	(Util.Element.get_all_classes(button)).indexOf('active') == -1 ) 
							Util.Element.add_class(button, 'active' /*'selected'*/);
						else
							if ( !state_querier() && (Util.Element.get_all_classes(button)).indexOf('active') > -1 )
								Util.Element.remove_class(button, 'active' /*'selected'*/);
					}
				);
			}

			Util.Element.add_class(button, 'tb');
			button.width = 21;
			button.height = 20;
			button.border = 0;
			button.setAttribute('unselectable', 'on');

			_textarea_toolbar.appendChild(button);
		};

		// Add each button to the toolbar
		if ( _settings.options.test('source') ) add_button('source.gif', 'Toggle source', function() { self.toggle_iframe_textarea(); });
	};

	/**
	 * Creates the iframe
	 */
	var _create_iframe = function()
	{
		_iframe = _owner_document.createElement('IFRAME');
		_iframe.src = _settings.base_uri + 'loki_blank.php';
		_iframe.frameBorder = '0'; // otherwise, IE puts an extra border around the iframe that css cannot erase

		// TODO: Take styles from textarea
	};

	/**
	 * Creates the statusbar
	 */
	var _create_statusbar = function()
	{
		_statusbar = _owner_document.createElement('DIV');
		Util.Element.add_class(_statusbar, 'statusbar');
	};

	/**
	 * Creates the hidden element for Loki, and sets the hidden
	 * element's name, id, and value to those of the textarea element.
	 */
	var _create_hidden = function()
	{
		_hidden = _owner_document.createElement('INPUT')
		_hidden.setAttribute('type', 'hidden');

		if ( _textarea.getAttribute('id') )
			_hidden.setAttribute('id', _textarea.getAttribute('id'));

		if ( _textarea.getAttribute('name') )
			_hidden.setAttribute('name', _textarea.getAttribute('name'));

		if ( _textarea.getAttribute('value') )
			_hidden.setAttribute('value', _textarea.getAttribute('value'));
	};

	/**
	 * Replaces the textarea with the root.
	 */
	var _replace_textarea = function()
	{
		_textarea.parentNode.replaceChild(_root, _textarea);
	};

	/**
	 * Append style sheets to format the main Loki box (not for
	 * dialogs etc.) to owner_document's head.
	 */
	var _append_owner_document_style_sheets = function()
	{
		Util.Document.append_style_sheet(_owner_document, _settings.base_uri + 'css/Loki.css');
	};

	/**
	 * Append style sheets to format the innards of the loki iframe
	 */
	var _append_document_style_sheets = function()
	{
		Util.Document.append_style_sheet(_document, '/global_stock/css/cssSelector.php3'); //this should perhaps be more generalized
		Util.Document.append_style_sheet(_document, '/global_stock/css/modules.css'); //this should perhaps be more generalized
		Util.Document.append_style_sheet(_document, '/global_stock/css/default_styles.css'); //this should perhaps be more generalized
// 		Util.Document.append_style_sheet(_document, '/global_stock/css/minisites_style.css'); //this should perhaps be more generalized
		Util.Document.append_style_sheet(_document, _settings.base_uri + 'css/Loki_Document.css');
	};
	
	/**
	 * Write out blank document. The key here is that we *close*
	 * the document. That way, we don't have to wait for any more
	 * load events, dealing with which is a royal pain in the
	 * cross-browser ass. Cf note in Util.Window.open.
	 */
	var _clear_document = function()
	{
		_document.open();
		_document.write(
			'<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">' +
			'<html><head><title></title></head><body>' +
			'</body></html>'
		);
		_document.close();
	};

	/**
	 * Make the document editable. Mozilla doesn't support
	 * contentEditable. Both IE and Mozilla support
	 * designMode. However, in IE if designMode is set on an iframe's
	 * contentDocument, the iframe's ownerDocument will be denied
	 * permission to access it (even if otherwise it *would* have
	 * permission). So for IE we use contentEditable, and for Mozilla
	 * designMode.
	 */
	var _make_document_editable = function()
	{
		// IE way
		try
		{
			_body.contentEditable = true;
			// If the document isn't editable, this will throw an
			// error. If the document is editable, this is perfectly
			// harmless.
			_query_command_state('Bold');
		}
		// Mozilla way
		catch(e)
		{
			try
			{
				// Turn on design mode.  N.B.: designMode has to be
				// set after the iframe_elem's src is set (or its
				// document is closed). ... Otherwise the designMode
				// attribute will be reset to "off", and things like
				// execCommand won't work (though, due to Mozilla bug
				// #198155, the iframe's new document will be
				// editable)
				_document.designMode = 'on';
				_document.execCommand('undo', false, null);
				//_query_command_state('Bold');
			}
			catch(f)
			{
				throw(new Error('UI.Loki._init_editor_iframe: Neither the IE nor the Mozilla way of starting the editor worked.'+
								'When the IE way was tried, the following error was thrown: <<' + e.message + '>>. ' +
								'When the Mozilla way was tried, the following error was thrown: <<' + f.message + '>>.'));
			}
		}

		// Tell Mozilla to use CSS.  Wrap in try block because IE
		// doesn't have a useCSS command, nor do some older versions
		// of Mozilla (even ones that support designMode),
		// e.g. Gecko/20030312 Mozilla 1.3 OS X
		try {
			_document.execCommand('useCSS', false, true);
		} catch (e) {}
	};

	/**
	 * Add certain event listeners to the document, e.g. to listen to
	 * key strokes, mouse clicks, and so on.
	 */
	var _add_document_listeners = function()
	{
		Util.Event.add_event_listener(_document, 'keydown', function(event)
		{
			event = event == null ? _window.event : event;
			Util.Fix_Keys.fix_enter_keydown(event, _window);
		});

		Util.Event.add_event_listener(_document, 'keyup', function(event) 
		{
			event = event == null ? _window.event : event;
			Util.Fix_Keys.fix_enter_keyup(event, _window);
		});

		Util.Event.add_event_listener(_document, 'keyup', function() { _update_statusbar(); });
		Util.Event.add_event_listener(_document, 'click', function() { _update_statusbar(); });
		Util.Event.add_event_listener(_toolbar, 'click', function() { _update_statusbar(); });

		// this copies the changes made in the iframe back to the hidden form element
		Util.Event.add_event_listener(_hidden.form, 'submit', function() { self.copy_iframe_to_hidden() });
	};

	/**
	 * Add listeners to all events which might change the state of the
	 * window (e.g., change where the current selection is in the
	 * document tree). This is useful for updating the toolbar
	 * (updating which buttons appear depressed) and the statusbar.
	 *
	 * The listeners added are stored in _state_change_listeners. We
	 * store them there and then add them all at once at the end of
	 * initialization (when this function should be called) instead of
	 * just adding them when we need them because it is convenient to
	 * add some of the listeners before _document actually points at
	 * some non-null thing.
	 *
	 * I do not like the name "state_change", but couldn't come up
	 * with anything better.
	 */
	var _add_state_change_listeners = function()
	{
		return; // YOU ARE HERE
		for ( var i = 0; i < _state_change_listeners.length; i++ )
		{
			Util.Event.add_event_listener(_document, 'keyup', _state_change_listeners[i]);
			Util.Event.add_event_listener(_document, 'click', _state_change_listeners[i]);
			Util.Event.add_event_listener(_toolbar, 'click', _state_change_listeners[i]);
		}
	};

	/**
	 * Update the statusbar with our current place in the document tree.
	 */
	var _update_statusbar = function()
	{
		var sel = Util.Selection.get_selection(_window);
		var rng = Util.Range.create_range(sel);
		var cur_node = Util.Range.get_common_ancestor(rng);
		var status = '';
		var i = 0;
		
		do
		{
			if ( i > 0 )
				status = ' > ' + status;

			if ( cur_node.nodeType == Util.Node.TEXT_NODE )
				status = '[TEXT]' + status;
			else if ( cur_node.nodeType == Util.Node.ELEMENT_NODE )
				status = cur_node.tagName + status;

			cur_node = cur_node.parentNode;
			i++;
		}
		while ( cur_node != null &&
				( cur_node.nodeType != Util.Node.ELEMENT_NODE ||
				  cur_node.tagName != 'HTML' ) )

		_statusbar.innerHTML = status;
	};

	/**
	 * Runs execCommand on _document. The motivation for this wrapper
	 * is to avoid issues when execCommand is used in event listeners.
	 * (If _document isn't yet initialized when "function() {
	 * _document.execCommand(xxx) }" is added as an event listener, an
	 * error results, because (in addition to its arguments) the
	 * listener when executed has access only to those variables which
	 * it had access to when it was defined.
	 *
	 * Also consult <a href="http://www.mozilla.org/editor/midas-spec.html">Mozilla's</a>
	 * and <a href="http://msdn.microsoft.com/workshop/author/dhtml/reference/methods/execcommand.asp">IE's</a>
	 * documentation.
	 *
	 * @param	command		the command to execute
	 * @param	iface		boolean indicating whether to use an interface. Not
	 *                      supported by Mozilla, so always provide false.
	 * @param	value		the value to pass the command
	 */
	var _exec_command = function(command, iface, value)
	{
		_window.focus();
		_document.execCommand(command, iface, value);
		_window.focus();
	};

	/**
	 * Returns the vfalue of _document.queryCommandValue (see the
	 * links on execCommands doc for more info). But first modifies
	 * the return value so that IE's is the same as Mozilla's. (On
	 * this see <a href="http://www.mozilla.org/editor/ie2midas.html">here</a>, 
	 * bullet 8.)
	 *
	 * See also on _exec_command.
	 *
	 * @param	command		the command whose value to query (this only works for 
	 *                      some of the commands)
	 * @return				the (possibly-modified) return value of queryCommandValue
	 */
	var _query_command_value = function(command)
	{
		// Not sure if the window.focus is actually helpful here ...
		// and it makes annoying things happen like dialogs popping up
		// behind the editor's containing window.
		//_window.focus();
		var value = _document.queryCommandValue(command);

		if ( command == 'FormatBlock' )
		{
			var mappings = 
			{
				// IE : Mozilla
				'Normal' : 'p',
				'Formatted' : 'pre',
				'Heading 1' : 'h1',
				'Heading 2' : 'h2',
				'Heading 3' : 'h3',
				'Heading 4' : 'h4',
				'Heading 5' : 'h5',
				'Heading 6' : 'h6',
				'Preformatted' : 'pre',
				'Address' : 'address'
			};
			if ( mappings[value] != null )
				value = mappings[value];
		}

		return value;
	}

	/**
	 * See on _exec_command.
	 */
	var _query_command_state = function(command)
	{
		// Not sure if the window.focus is actually helpful here ...
		// and it makes annoying things happen like dialogs popping up
		// behind the editor's containing window.
		//_window.focus();
		return _document.queryCommandState(command);
	}

	/**
	 * Formats a block as specified if it's not so, and if it is so,
	 * formats it as a normal paragraph.
	 *
	 * @param   tag     the tag name corresponding to how you want
     *                  the block to be formatted. See <code>mappings</code>
     *                  variable inside the function.
     *
	 */
	var _toggle_block = function(tag)
	{
		if ( _query_command_value('FormatBlock') != tag )
		{
			_exec_command('FormatBlock', false, '<' + tag + '>');
		}
		else
		{
			_exec_command('FormatBlock', false, '<p>');
		}

		_window.focus();
	};

	/**
	 * Formats a block as a list of the given type if it's not so, and
	 * if it is so, formats it as a normal paragraph. This is
	 * necessary because in Mozilla, if a block is already formatted
	 * as a list, the Insert[Un]orderedList commands simply remove the
	 * block's block-level formatting, rather than changing it to a
	 * paragraph.
	 *
     * @param   tag     the tag name corresponding to how you want
     *                  the block to be formatted. See mappings variable 
     *                  inside the function
     */
	var _toggle_list = function(tag)
	{
		var command = tag == 'ol' ? 'InsertOrderedList' : 'InsertUnorderedList';

		if ( _query_command_state(command) )
		{
			_exec_command(command); // turn off the list
			_toggle_block('p');
		}
		else
		{
			_exec_command(command); // turn on the list
		}
	};

	/**
	 * Inserts a break tag, or if we're using paragraph hacks, a faux
	 * break tag.
	 */
	var _insert_br = function()
	{
		var sel = Util.Selection.get_selection(_window);
		if ( _use_p_hacks )
		{
			var br = _document.createElement('SPAN');
			Util.Element.add_class(br, 'loki__is_really_a_br');
			br.setAttribute('loki:is_really_a_br', '1');
		}
		else
		{
			var br = _document.createElement('BR');
		}
		Util.Selection.insert_node_at_selection(sel, br);
		_window.focus();	
	};

	/**
	 * Inserts a horizontal rule.
	 */
	var _insert_hr = function()
	{
		var sel = Util.Selection.get_selection(_window);
		var hr = _document.createElement('HR');
		Util.Selection.insert_node_at_selection(sel, hr);
		_window.focus();	
	};

	/**
	 * Gets the element contained by current selection 
	 * that is highlightable. If no such exists, returns null.
	 */
	var _get_highlightable_paragraph = function()
	{
		var is_table_elem = function(node)
		{
			 return ( (new RegExp('td', 'i')).test(node.tagName) ||
					  (new RegExp('table', 'i')).test(node.tagName) );
		}

		var is_highlightable = function(node)
		{
			return ( node.nodeType == Util.Node.ELEMENT_NODE &&
					 (new RegExp('p', 'i')).test(node.tagName) &&
					 !Util.Node.has_ancestor_node(node,  is_table_elem) );
		}

		var sel = Util.Selection.get_selection(_window);
		var rng = Util.Range.create_range(sel);
		var elem = Util.Range.get_nearest_ancestor_node(rng, is_highlightable);

		return elem;
	};

	/**
	 * Highlights or unhighlights the current paragraph.
	 */
	var _highlight_paragraph = function()
	{
		var elem = _get_highlightable_paragraph();
		if ( elem != null )
		{
			var class_name = 'callOut';
			if ( Util.Element.has_class(elem, class_name) )
				Util.Element.remove_class(elem, class_name);
			else
				Util.Element.add_class(elem, class_name);
		}
		_window.focus();	
	};

	/**
	 * Queries whether the current paragraph is highlightable, 
	 * or highlighted. Returns accordingly.
	 */
	var _query_highlight_paragraph = function()
	{
		// XXX: when you make a proper toolbar-updating
		// system, obviously something other than these
		// strings will have to be returned.

		var elem = _get_highlightable_paragraph();
		if ( elem != null )
		{
			if ( Util.Element.has_class(elem, class_name) )
				return 'Highlighted';
			else
				return 'Highlightable';
		}
		else
			return 'Not highlightable';
	};

	var _open_image_dialog = function()
	{
		var sel = Util.Selection.get_selection(_window);
		var rng = Util.Range.create_range(sel);
		//var surrounding_node = Util.Range.get_common_ancestor(rng);

		var selected_item;
		var cloned_children = Util.Range.get_cloned_children(rng);
		if ( cloned_children.length > 0 &&
			 cloned_children[0].nodeType == Util.Node.ELEMENT_NODE &&
			 cloned_children[0].tagName == 'IMG' )
		{
			var selected_image = cloned_children[0];
			selected_item =
			{
				uri : selected_image.getAttribute('src'),
				alt : selected_image.getAttribute('alt'),
				align : selected_image.getAttribute('align')
			}; 
		}

		var image_dialog = new UI.Image_Dialog;
		image_dialog.init({ data_source : _settings.images_feed,
							base_uri : _settings.base_uri,
							submit_listener : _insert_image,
							selected_item : selected_item });
		image_dialog.open();
	};

	var _insert_image = function(image_info)
	{
		// Create the image
		var image = _document.createElement('IMG');
		image.setAttribute('src', image_info.uri);
		image.setAttribute('alt', image_info.alt);

		if ( image_info.align != '' )
			image.setAttribute('align', image_info.align);
		else
			image.removeAttribute('align');

/*
		if ( image_info.border == 'yes' )
			Util.Element.add_class(image, 'bordered');
		else
			Util.Element.remove_class(image, 'bordered');
*/

		// Insert the image
		var sel = Util.Selection.get_selection(_window);
		var rng = Util.Range.create_range(sel);
		Util.Range.delete_contents(rng);
		Util.Range.insert_node(rng, image);

		_window.focus();	
	};

	var _open_table_dialog = function()
	{
		var sel = Util.Selection.get_selection(_window);
		var rng = Util.Range.create_range(sel);

		var table_dialog = new UI.Table_Dialog;
		table_dialog.init({ base_uri : _settings.base_uri,
							submit_listener : _insert_table,
							selected_item : selected_item });
		table_dialog.open();
	};

	var _insert_table = function(table_info)
	{
		  
	};
	//this.init(textarea);


	///////////////////////////////
	//
	// Ghetto for hel-based dialogs
	//
	///////////////////////////////

	/**
	 * Opens a modal window with the specified location. The modal
	 * window will have access to this object via opener.<?php echo
	 * $_REQUEST['editor_id'] ?>, and it should call the appropriate
	 * method to pass back variables and do other interesting things.
	 */
	_hel_open_dialog = function(modal_url, width, height)
	{
		var the_window = window.open(modal_url, 'hel_modal_window', 'chrome,modal,dialog,resizable=yes,width='+width+',height='+height);
	};

	/**
	 * Opens a modal dialog box to insert a link, using the old hel
	 * model. Note that most of this function would, really all but
	 * the end, work perfectly well without the hel framework.
	 *
	 * @param	type	string specifying what kind of link dialog to open.
	 *                  Options include:  'link', 'asset', 'email', and
	 *                  'image'. Default is 'link'.
	 */
	var _hel_open_link_dialog = function(type)
	{
		var sel = Util.Selection.get_selection(_window);
		var rng = Util.Range.create_range(sel);

		var url = '', new_window = null, title = '';
		var link_boolean_test = function(node)
		{
			try
			{
				messagebox('just before testing nodeType');
				var return_val = ( node.nodeType == Util.Node.ELEMENT_NODE &&
								   node.tagName == 'A' );
				messagebox('just after testing nodeType');
				return return_val;
			}
			catch(e)
			{
				return false;
			}
// 			return ( node.nodeType == Util.Node.ELEMENT_NODE &&
// 					 node.tagName == 'A' );
		};

		// First, look for anchor inside the range
		var cloned_children = Util.Range.get_cloned_children(rng);
		for ( var i = 0; i < cloned_children.length; i++ )
		{
			messagebox('got cloned_children');
			var cloned_child = cloned_children[i];
			if ( link_boolean_test(cloned_child) )
			{
				url = cloned_child.getAttribute('href');
				new_window = ( cloned_child.hasAttribute('target') &&
							   cloned_child.getAttribute('target') != '_self' &&
							   cloned_child.getAttribute('target') != '_parent' &&
							   cloned_child.getAttribute('target') != '_top' );
				title = cloned_child.getAttribute('title');
				break;
			}
		}

		// Second, look for anchor surrounding the range
		if ( url == '' )
		{
			var parent_node = Util.Range.get_nearest_ancestor_node(rng, link_boolean_test);
			messagebox('got nearest ancestor node');
			if ( parent_node != null )
			{
				url = parent_node.getAttribute('href');
				new_window = ( parent_node.hasAttribute('target') &&
							   parent_node.getAttribute('target') != '_self' &&
							   parent_node.getAttribute('target') != '_parent' &&
							   parent_node.getAttribute('target') != '_top' );
				title = parent_node.getAttribute('title');

				// So that execCommand sees the parent_node (i.e., sees the entire anchor node):
				rng.setStartBefore(parent_node);
				rng.setEndAfter(parent_node);
				//sel.addRange(rng);
			}
		}

		_insert_link("http://www.google.com", false, "Google is coole."); // XXX temp
		return; /// XXX temp

		// Find named anchors in the editor, to pass to the window
		var named_anchors = new Array();
		var all_anchors = _document.getElementsByTagName('IMG');
		var j = 0;
		for (i = 0; i < all_anchors.length; i++)
		{
			if ( all_anchors[i].getAttribute("loki:is_really_an_anchor_whose_name") != null)
			{
				named_anchors[j] = document.createElement('A');
				named_anchors[j].name = all_anchors[i].getAttribute("loki:is_really_an_anchor_whose_name");
				j++;
			}
		}

		window.temp_modal_args = {};
		window.temp_modal_args.named_anchors = named_anchors;
		window.temp_modal_args.link_url = url;
		window.temp_modal_args.link_new_window = new_window;
		window.temp_modal_args.link_title = title;
		window.temp_modal_args.loki_obj = self;
		window.temp_modal_args.insert_link = _insert_link;

		if ( type == 'asset' )
			_hel_open_dialog(_settings.base_uri + 'dialogs/hel_link_to_asset.php?site_id=' + _settings.site_id, 500, 300);
		else if ( type == 'email' )
			_hel_open_dialog(_settings.base_uri + 'dialogs/hel_link_to_email.php?site_id=' + _settings.site_id, 500, 375);
		else if ( type == 'image' )
			_hel_open_dialog(_settings.base_uri + 'dialogs/hel_image.php?site_id=' + _settings.site_id, 600, 450);
		else
			_hel_open_dialog(_settings.base_uri + 'dialogs/hel_link.php?site_id=' + _settings.site_id, 450, 375);
	}


	/*
	 * Inserts a link, and will typically be called from inside the
	 * modal_link window itself
	 */
	var _insert_link = function(url, new_window, title, onclick)
	{
		url = url.replace( /\%7E/g, '~' ); //so that users of older versions of Mozilla aren't confused by this substitution

		if ( url != '' ) _exec_command('CreateLink', false, 'hel_temp_url');
		else             _exec_command('unlink', false, null);

		var links = _document.getElementsByTagName('a');
		for (var i = 0; i < links.length; i++)
		{
			if ( links.item(i).getAttribute('href') == 'hel_temp_url')
			{
				links.item(i).setAttribute('href', url);

				if ( new_window == true )  links.item(i).setAttribute('target', '_blank');
				else                       links.item(i).removeAttribute('target');

				if ( title != '' ) links.item(i).setAttribute('title', title);
				else               links.item(i).removeAttribute('title');

				if ( onclick != '' ) links.item(i).setAttribute('loki:onclick', onclick);
				else                 links.item(i).removeAttribute('loki:onclick');
			}
		}
	}
};


