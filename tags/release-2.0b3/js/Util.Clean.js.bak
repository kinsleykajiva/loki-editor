/**
 * Does nothing.
 * @constructor
 *
 * @class <p>Contains methods related to producing clean, valid,
 * elegant HTML from the mess produced by the designMode = 'on'
 * components. Named after Lakshmi, the Hindu goddess of
 * cleanliness.</p>
 *
 * <p>JSDoc doesn't work well with this file. See the code for more
 * details about how it works.</p>
 */
Util.Clean = new Object;

/**
 * Cleans the children of the given root.
 *
 * @param	root	reference to the node whose children should be cleaned
 */
Util.Clean.clean = function(root)
{
	/////////////////////////////////////////////
	//
	// LOCAL FUNCTIONS
	//
	////////////////////////////////////////////

	/*
	 * Removes any br's which immediately preceed the closing tag of a
	 * block-level element. E.g.:
	 *
	 *   <p>asdf<br /><br /><br /></p>  ==>  <p>asdf</p>
	 *   <p>asdf<br /></p>  ==>  <p>asdf</p>
	 *
	 * @param	root	reference to the node whose children should be purged of extra brs
	 * @private
	 */
	function _remove_trailing_brs(root)
	{
		var brs = root.ownerDocument.getElementsByTagName('br');
		var brs_to_be_deleted = Array(); // we use this so that brs does not change in length while we're looping through it (otherwise, some brs will be skipped)

		// Push trailing brs onto brs_to_be_deleted
		for ( var i = 0; i < brs.length; i++ )
		{
			var br = brs.item(i);
			var nearest_bl_ancestor = Util.Node.get_nearest_bl_ancestor_element(br);
			var last_child_of_nearest_bl_ancestor = Util.Node.get_last_non_whitespace_child_node(nearest_bl_ancestor);
			if ( last_child_of_nearest_bl_ancestor == br )
			{
				// 1. Add any previous sibling brs of br to brs_to_be_deleted
				var next_sibling_of_br;
				var sibling_of_br = Util.Node.get_nearest_non_whitespace_sibling_node(br, Util.Node.PREVIOUS);
				while ( sibling_of_br != null && sibling_of_br.nodeType == Util.Node.ELEMENT_TYPE && sibling_of_br.tagName == 'BR' )
				{
					next_sibling_of_br = Util.Node.get_nearest_non_whitespace_sibling_node(sibling_of_br, Util.Node.PREVIOUS);
					brs_to_be_deleted.push(next_sibling_of_br);
					sibling_of_br = next_sibling_of_br;
				}

				// 2. Add br itself to brs_to_be_deleted
				brs_to_be_deleted.push(br);
			}
		}

		// Remove the brs in brs_to_be_deleted
		while ( brs_to_be_deleted.length > 0 )
		{
			var br = brs_to_be_deleted.pop();
			br.parentNode.removeChild(br);
		}
	}

	function _format_blocks(root)
	{
		_format_blocks_recursive(root);
	}

	function _format_blocks_recursive(cur)
	{
		var children = cur.childNodes;
		for ( var i = 0; i < children.length; i++ )
		{
			var child = children.item(i);
			// if ( _is_block_level_element )
			// if ( Util.Node.is_ble )
			// if ( Util.Element.is_ble )
			if ( Util.Node.is_block_level_element(child) )
			{
				_format_blocks_recursive(child);
				_format_block(child);
			}
		}
	}

	function _format_block(root)
	{
		var doc = root.ownerDocument;
		// needs to be fixed:
		var children_frag = doc.createDocumentFragment(); // holds the children nodes which will be copied to root_frag is two brs are encountered
		var root_frag = doc.createDocumentFragment(); // holds the fragment which will replace root when all the brs have been dealt with

		var count_of_double_brs = 0;
		var children = root.childNodes;
		for ( var i = 0; i < children.length; i++ )
		{
			var child = children.item(i);
			var sibling_of_child = Util.Node.get_nearest_non_whitespace_sibling_node(child, Util.Node.NEXT);

			if ( child.nodeType == Node.ELEMENT_NODE && child.tagName == 'BR' &&
				 sibling_of_child != null && sibling_of_child.nodeType == Node.ELEMENT_NODE && child.tagName == 'BR' )
			{
				// Move the index to sibling_of_child, so that neither
				// of the double brs is copied into the new frag on
				// the next pass
				i = get_index_of(sibling_of_child, children, i);
				append_x_as_appropriate_for_ble_y_to_z(children_frag, root, root_frag, true);
				count_of_double_brs++;
				children_frag = doc.createDocumentFragment(); // TEMP: perhaps it would be better to just remove all the child nodes (but would that then remove them also from p?)
			}
			else
			{
				children_frag.appendChild(child.cloneNode(true)); // TEMP: we only need to clone the node now, so the original document doesn't get messed up
//				children_frag.appendChild(child); // TEMP: we only need to clone the node now, so the original document doesn't get messed up
			}
		}

		// Append the last fragment. This will be either (a) anything
		// between the last occurrence of double brs and the closing
		// tag of root, or (b) (if there are no double brs) all the
		// children of root.
		if ( count_of_double_brs > 0 )
			append_x_as_appropriate_for_ble_y_to_z(children_frag, root, root_frag, true);
		else
			append_x_as_appropriate_for_ble_y_to_z(children_frag, root, root_frag, false);


		// If the root cannot contain ps, then replace the root
		// entirely with the root_frag (which will have a bunch of
		// clones of root). Otherwise, append the root_frag (which
		// will not have clones of root) to a clone of root without
		// its original children, and replace root with the clone.
		if ( Util.BLE_Rules.cncp.regexp.test(root.tagName) )
		{
			root.parentNode.replaceChild(root_frag, root);
		}
		else
		{
			var root_sans_orig_children = root.cloneNode(false);
			root_sans_orig_children.appendChild(root_frag);
			root.parentNode.replaceChild(root_sans_orig_children, root);
		}
	}

	function append_x_as_appropriate_for_ble_y_to_z(children_frag, root, root_frag, there_is_more_than_one_p)
	{
		var doc = root.ownerDocument;

		//
		// If root is a block-level element which cannot contain ps, then
		// append children_frag to a clone of root. This should lead to
		// results like this:
		//
		//   <p class="callout">asdf<br /><br />asdf</p>  
		//       ==> 
		//   <p class="callout">asdf</p><p class="callout">asdf</p>
		//
		if ( Util.BLE_Rules.cncp.regexp.test(root.tagName) )
		{
			var new_node = root.cloneNode(false); // false => don't include child nodes in the clone
			new_node.appendChild(children_frag.cloneNode(true)); // TEMP: the cloneNode might not be necessary
			root_frag.appendChild(new_node);
		}
		//
		// The behavior here, in contrast to the behavior when a user hits
		// enter, is the same for block-level elements which can contain
		// (any number of) ps and those which can contain only more than
		// one p. This is to avoid results like this:
		//
		//   <blockquote><p class="callout">asdf<br /><br />asdf</p></blockquote>  
		//       ==> 
		//   <blockquote><p><p class="callout>asdf</p><p class="callout">asdf</p></p></blockquote>
		//
		// which are obviously illegal. Such results would happen if for
		// ccp ble's the code in the if-statement below were run
		// regardless of whether there_is_more_than_one_p == true.
		//
		// The behavior here is instead like this:
		//
		//  1. There_is_more_than_one_p == false.
		//
		//   <blockquote>asdf</blockquote>
		//      ==>
		//   <blockquote>asdf</blockquote>
		//
		//  2. There_is_more_than_one_p == false. (First, the p cncp
		//  above, and so is split into two p's. Second, the blockquote
		//  matches ccp and there_is_more_than_one_p==false, so its
		//  children are untouched.)
		//
		//   <blockquote><p class="callout">asdf<br /><br />asdf</p></blockquote>  
		//       ==> 
		//   <blockquote><p class="callout>asdf</p><p class="callout">asdf</p></blockquote>
		//
		//  3. There_is_more_than_one_p == true.
		//
		//   <blockquote>asdf<br /><br />asdf</p></blockquote>  
		//       ==> 
		//   <blockquote><p>asdf</p><p class="callout">asdf</p></blockquote>
		//
		else if ( Util.BLE_Rules.ccomtop.regexp.test(root.tagName) || Util.BLE_Rules.ccp.regexp.test(root.tagName) )
		{
			if ( there_is_more_than_one_p )
			{
				var new_node = doc.createElement('p');
				new_node.appendChild(children_frag.cloneNode(true)); // TEMP: the cloneNode might not be necessary
				root_frag.appendChild(new_node);
			}
			else
			{
				root_frag.appendChild(children_frag.cloneNode(true)); // TEMP: the cloneNode might not be necessary
			}
		}
		//
		// If root is a block-level element which can contain double br's
		// but not p's, then append children_frag to a clone of root. This
		// should lead to results like this:
		//
		//   <li>asdf<br /><br />asdf</li>
		//       ==> 
		//   <li>asdf<br /><br />asdf</li>
		//
		else // if ( Util.BLE_Rules.ccdbbnp.regexp.test(root.tagName) )
		{
			// We need to append the brs here because they're not included
			// in children_frag.  Perhaps it would be better here to
			// somehow try to get at the original brs used, in case they
			// have attributes set.
			var br1 = doc.createElement('br');
			var br2 = doc.createElement('br');
			root_frag.appendChild(children_frag.cloneNode(true)); // TEMP: the cloneNode might not be necessary
			root_frag.appendChild(br1);
			root_frag.appendChild(br2);
		}
	}



	/////////////////////////////////
	//
	// EXECUTION
	//
	/////////////////////////////////
	_remove_trailing_brs(root);
	_format_blocks(root);
};
